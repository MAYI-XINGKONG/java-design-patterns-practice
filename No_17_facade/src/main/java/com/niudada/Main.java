package com.niudada;

import com.niudada.order.OrderFacade;

/**
 * 总结和笔记就写到这了：
 * 1、外观模式:是结构型设计模式,它主要是封装并隐藏复杂子系统的功能,通过创建一个外观类来提供简单的接口,让客户端访问;
 * 2、Demo:当前Demo中子系统有：支付、库存、物流,用一个外观类OrderFacade来处理,客户端使用就只需要调用OrderFacade类即可;
 * 3、优点就是简化客户端使用,降低耦合度,有助于建立分层结构(每一层只通过外观类提供服务,相当于入口点);
 * 4、缺点也显而易见,首先可能会违反开闭原则(添加新功能就要修改外观类,可能还会修改对应的逻辑);
 *   其次限制了客户端灵活性 有些步骤客户端可能不需要 比如数字类商品是不需要发货的 当然具体业务中肯定有相应的业务逻辑 但是不能完全忽略;
 *   子系统特别复杂时 可能会导致外观类非常庞大 承担过多职责;相反,对于简单的系统 外观模式就显得有些过度设计了(就像本项目,虽然是为了学习和练习 但抛去这个不说难道就没有问题吗 (∩❛ڡ❛∩) 没几行代码还硬要套用设计模式...);
 * 5、对于上述这些缺点 还是那句话,具体情况具体分析 合理使用设计模式,对于外观模式 一般是用在复杂系统中,需要遵循单一职责原则 可以创建多个专门的外观类而不是一个全能外观 并且可以通过参数控制外观的行为;
 * 总结：外观模式虽然能简化复杂系统的使用,但也可能会带来额外的复杂性和限制,所以需要根据具体的情况来权衡 确保是真正来解决问题的而不是来增加新问题的.
 */
public class Main {
    public static void main(String[] args) {
        // 用外观模式处理订单Demo流程
        OrderFacade orderFacade = new OrderFacade();
        orderFacade.processOrder("ORD-20250822-001");
    }
}